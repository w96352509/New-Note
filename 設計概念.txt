範例整理 :
 DesignPattern :
   -> session01 :
        DuckDesign -> 工廠練習(FactoryMode) / Book(書本範例) -> new(加入策略模式加簡單工廠模式) / old(未套模式)
        Game       -> 策略模式練習(武器更換)
		StrategyMode -> 策略模式練習(計算機)
   
   -> session02 : book  -> meteorological (氣象站訂閱者模式練習)		
                           meteorological2(氣象站訂閱者模式練習) // 使用 JavaAPI
			      Drink -> 工廠模式	
                  phone -> 工廠 + 訂閱者
   
   -> session03	: Decorator -> (書中的咖啡店練習裝飾模式)
                  SingletonFactory -> (網上單例模式)   
						  
設計概念 :
 1. 把可能需要變動的程式獨立出來
 2. 方法針對介面處理                            // "執行時"期動態的"改變"
 3. 多用實作                                    // 可將細部功能封裝起來
 4. 盡量讓需要互相的物件之間關係鬆綁            // 觀察者模式 
 5. 類別應該開放 , 以便擴充 , 也該關閉禁止修改  // OCP 開放關閉原則

系統是什麼 :
 1. 實現某些功能
 2. 功能複雜時需要由概念整理
 3. 概念轉換為系統架構
 4. 架構進行模組化
 5. 程式碼堆砌而成

設計模式很像模組 , 由物件導向特性組成 
-------------------------------------------------------------------


目錄 :
 1. 策略模式   : 當相同方法於不同物件時要有不同實作時使用
 2. 工廠模式   : 需要重複宣告物件時可以統一起來呼叫
 3. 訂閱者模式 : 1 對 多 時使用
 4. 單例模式   : 全部人使用同一個類別
 5. 裝飾者模式 : 想要隨時更改物件方法時使用


-------------------------------------------------------------------


使用介面的用意 :
 關鍵 "多型" -> 執行時會根據情況到真正的行為不會被綁死到超類別 -(得知)> 變數宣告應該是超類型(抽象 or 介面)
             -> 意味 : 宣告時不用理會執行後的物件型態

-------------------------------------------------------------------


普通工廠模式 : 
  前言 : 你跟工廠說你想要的那種規格的商品      // 商品由工廠產生 
         而工廠負責製造你想要的那種規格的商品  // 工廠提供客製化方法
  
  優點 : 客製化 / 工廠類用於建立物件 / 只需要知道具體產品類名(Duck) / 防止對資料的破壞實現多型((DuckFactoryImpl)duckFactory)
  
  範本 : 
    
	Product : 
	         介面 : Duck -> void NarrativeDuck();
             類別 : DuckImpl implements Duck -> String type / 有無參數建構式 / 覆寫 NarrativeDuck();
    
	Factory :
             介面 : DuckFactory -> Duck getDuck();
             類別 :	DuckFactoryImpl implements DuckFactory -> 覆寫 Duck getDuck() return new Duck; / 
			                                                  超載 Duck getDuck(String type) return new Duck(type); 
    Main :
             1. 呼叫工廠               -> DuckFactory duckFactory = new DuckFactoryImpl(); 	
             2. 由工廠產生商品         -> Duck duck  = duckFactory.getDuck();
			 3. 由工廠產生商品(客製化) -> Duck duck2 = ((DuckFactoryImpl)duckFactory).getDuck("塑膠鴨");
			 4. 實現產品方法           -> duck.NarrativeDuck(); / duck2.NarrativeDuck();
    
	總計 : 由 Main 得知 -> 使用者只需要知道 工廠類方法 / 產品類   

總結: 工廠(類 or 方法) return 類 ? //  

           	
-------------------------------------------------------------------


策略模式 :
  前言 : 定義一系列算法 , 封裝至公共介面
         策略模式用策略的介面來替換在某個實體中的方法 , 可以經由替換不同的策略使得物件擁有不同的行為
		 // 相同型別可以呼叫不同方法

  優點 : 靈活的替換不同的行為 / 策略拓展容易 / 少用 id else  

  範本 : 
    
	Interface : IStrategy -> int caculate(int a , int b); // 公共介面

    策略class : Add / Div / Miuns implements IStrategy
    
    組裝 Calculator : 
	       private IStrategy iStrategy; 
	       public int execute(int a , int b){return iStrategy.caculate(a,b);} // 使用 switch 更換策略
		   public void setStrategy(DoType doType) {}                          // enum DoType{ADD , MINUS , DIVIDE}
		   // this.iStrategy = new Add(); , this.iStrategy = new Miuns(); , this.iStrategy = new Div()
	
    Main : 
	  1. 呼叫 Calculator -> 設定策略.setStrategy(DoType doType)	-> 呼叫方法.execute(1,2)
	    
    總計 : 由 Main 得知 -> 使用者只需要知道組裝後的物件 , 可以隨時更換策略 

總結: 使用公用介面(interface)封裝演算法(class)

-------------------------------------------------------------------


觀察者模式 : 定義了一對多的關係 , 當主題(subject)物件改變 , 訂閱者(observer)改變都會收到通知並自動更新
  
  前言 : 出版者(主題) + 訂閱者(觀察者) = 觀察者模式 
         舉例 : (單)頻道(主題) -(頻道內容改變)-> (多)訂閱觀眾(得到通知)	
         
  
  定義 : 每個物件都可有很多 Observer
    
	interface : Subject  -> registerObserver() / removeObserver() / notifyObserver() // 主題介面 , 利用介面成為觀察者 or 退出
              : Observer -> update() // 所有 Observer 都要實踐 observer 介面 , update() 當主題改變時呼叫	
	
    class     : ConcreteObserver implements Observer -> update() ....
                ConcreteSuject   extends    Subject  -> registerObserver() / removeObserver() / notifyObserver() / getset...	
	            // 
	
  結語 : 
    1. 觀察者模式定義 1 對多
    2. 主題更新 Observer 是透過共同介面
	3. Subject 與 Observer 是鬆綁關系 : Subject 不知道 Observer 的細節
	4. 多 Observer 不可依賴特定順序
	5. 也可透過 java.util. Observable(class) 完成(下方範例)


-------------------------------------------------------------------


單例模式 : 只有一個實例，而且自行實例化並向整個系統提供這個實例

  前言 : 類別只提供創建自己類別的方法
  
  目的 ： 保證一個類別只會產生一個物件，而且要提供存取該物件的統一方法
  
  Singleton：很簡單的只有一個類別，其中提供存取自己物件的方法，確保整個系統只有實例化一個物件。

  模式 :
   1. 懶散(Lazy)模式（線程不安全）
   2. 懶散模式（線程安全）
   3. 積極模式                   
   4. 雙重鎖 (Double ChockLock)
   5. 登記式（靜態內部類）: 可以確保線程安全，保證物件唯一性，並且延遲實例化，所以推薦使用
   6. 枚舉 (enumeration)
   
  舉例 :
    class : SingleObject
      -> private static SingleObject instance                       // 創建對象
      -> private SingleObject(){}	                                // 建構式為 private 只能透過其他方法來調用這個類
      -> public static SingleObject getInstance(){return instance;}	// 唯一可以獲取對象(自己)  

      1. 積極模式(宣告時初始化) : 
	       private static SingleObject instance = new SingleObject(); 
      
	  2. 懶散模式(呼叫獲取方法時(getInstance())才進行初始化) :
           public static synchronized Singleton getInstance(){   // synchronized 確保物件唯一性(防止多 Thread)
                                                                 // 每次呼叫都需要同步(效率低)		   
		     if (instance == null)
				{
					instance = new Singleton();
				}
					return instance;
		   } 	  
      
	  3. 雙重鎖 DLC (將懶散模式的同步改放到第二層)
	       public static Singleton getInstance(){

		   // 第一層判斷為了避免不必要的同步
		   if(instance == null){
					
		     synchronized (Singleton.class){
		       // 第二層判斷為了在null的狀況下建立實例
			   if(instance == null)
			     {
					instance = new Singleton();
				 }
			 }

		   }
           return instance;
		}
		
      4. 登記式(靜態內部類) 		
           public class : StaticInnerClass       -> (private 建構式) / getInstance( StaticInnerClassHolder.instance; ) 取得內部類別
		   static class : StaticInnerClassHolder -> private static StaticInnerClass instance = new StaticInnerClass();        

  範例(工廠模式 + 登記式) :
    interface :
	  Factory : Product getProduct();
 
	class : 
	  Product : -> getName(){ return this.getClass().getSimpleName(); }
	  
	  Cola / Humberger extends Product
	  
	  // 工廠
	  SingletonFactory : 取得內部類別方法 :
	                     內部類別 : ColaFactory & HumbergerFactory implements Factory / 初始化宣告工廠 / private 建構式 / 
						            實踐 getProduct(){ return new ... }; 
	  
  結語 : 可以確保類別只有一個實例 / 可以提供全局訪問點 
         全部人使用同一個類別(全部人喝同一口井概念)

------------------------------------------------------------------- 


書本第一章(鴨子模擬器) : 了解設計模式
  零設計模式 :
    一.
      class Duck : quack() / swim() / abstract display()  // 所有鴨都會 quack() / swim() , 每種鴨外觀不同 display()
      class plasticDuck / RedheadDuck extends Duck
     
	二. 加入 fly() 方法
      class Duck : quack() / swim() / fly() / abstract display() // 所有鴨都會 quack() / swim() , 每種鴨外觀不同 display() 	 
      class plasticDuck / RedheadDuck / RubberDuck extends Duck  // RubberDuck 不會飛(問題發生)
	  
    
	導致 : 多次重複 / 不意改變 / 難以得知全部行為 / 改變導致全不受影響 / 每隻鴨子都需要覆寫
	結語 : 由此得知涉及<維護> 為了<再利用> 使用 extends 不會有好結果

  優化 1 -> 把可能需要變動的程式獨立出來 (quack() / fly()) 並提供介面讓細部動作去實做
    
	一. 介面 <--- 細部功能
     interface : Fly -> fly()     <--- FlyYes -> fly(實踐飛行) / FlyNo -> fly(啥都不做) 
	 interface : Quack -> quack() <--- YesQuack -> quack(叫)   / YesQuack -> quack(不叫) / 等等叫聲...
     // 讓 Fly 與 Quack 物件可被再三利用 , 新增細部功能時也不會影響使用其他細部的功能

    二. 設定 Duck
      class Duck : 宣告介面 : Fly fly , Quack quack
	               方法     : swim() / abstract display() / 
				              total(Fly fly , Quack quack){swim() , display() , fly.fly() , quack.quack()}  
	
	三. 設定其他種類 Duck : RubberDuck extends Duck
      class RubberDuck    :覆寫 display();

    四. Main -> Duck RubberDuck = new RubberDuck(); -> RubberDuck.total(new NFly(), new YQuack());

    優點 : 不確定功能獨立出來 , 不用重覆覆寫 , 設定策略即可
	       執行實只需要呼叫主型別並呼叫所有方法設定策略	


書本第二章(氣象監測系統) : 觀察者模式
    
  說明 : 氣象站 <-(取得資料) Weather 物件 -(顯示)> 顯示裝置
         氣象站提供 : WeatherData -> getTemperature()          // 取得溫度 
		                           / getHumidity()             // 取得濕度 
								   / getPressure()             // 取得壓力
								   / measurementsChanged()     // 更新資料時呼叫此方法

  目前知道 : 3 個 get 方法 / 1 個被呼叫方法 / 更需要 3 個顯示(需可擴充)
  
  設計 :
        interface :
		  
		  1. Subject        : void registerObserver(Observer o); / void removeObserver(Observer o); // 主題介面
		                      void notifyObserver();                      
		  
		  2. Observer       : void update(float temp , float humidity , float pressure);  
                              // 當氣象數據改變 , Subject 會把這些參數傳給 Observer		  
		  
		  3. DisplayElement : display()  // 當佈告版需要顯示資料時使用 , 因每個佈告版資料都不同 , 所以獨立出來
        
		Class :
		  1. WeatherData implements Subject :
              屬性 :
			    1. private ArrayList<Observer> observers = new ArrayList<>(); // 多個訂閱者
                2. private float temp;      // 溫度
				3. private float humidity;  // 濕度
				4. private float pressure;	// 氣壓			
		 
		      實踐 :
			    1. registerObserver(Observer o){ observers.add(o); } // 新增 Observer
                2. removeObserver(Observer o)  { int i = observers.indexOf(o); if(i>=0){observers.remove(i)}} // 刪除 Observer
                3. notifyObserver(){ for -> observers.size() -> 得到 Observers.get(i) -> observer.update(....) } 
				   // 更新資料給 observer				
                
			  方法 :	
				1. measurementsChanged() -> 呼叫 notifyObserver();
				2. setMeasurements(float temp , float humidity , float pressure){
				    this.temp = temp;
					this.humidity = humidity;
					this.pressure = pressure;
					measurementsChanged();  
				   }
            
			2. CurrentConditionDisplay implements Observer , DisplayElement
                屬性 :
                  1. private float temp;
	              2. private float humidity;
	            
                建構 :
                  1. public CurrentConditionDisplay(Subject weatherData) { weatherData.registerObserver(this); }
                     // 幫助在 Main 時 , 宣告 CurrentConditionDisplay 時並把自己加入主題
                  
                實踐 : 
                  1. display() -> sout(....)
                  2. update(float temp, float humidity, float pressure){
				        this.temp = temp;
						this.humidity = humidity;
						display();
				     }			  
            
			3. Main : 
                 1. 新建具體的主題物件 WeatherData weatherData = new WeatherData();  
                 2. 新建 Observer = CurrentConditionDisplay conditionDisplay = new CurrentConditionDisplay(weatherData); 
				 3. 更新主題參數

  方法順序 : 
    1. Observer 建構時加入 Subject // 因此 CurrentConditionDisplay 進入 Observers 陣列中
	2. setMeasurements(80, 65, 30) -> measurementsChanged() -> notifyObserver() -> observer.update(temp, humidity, pressure);
	                               -> display()
  
  總結 : Observer 透過建構式加入 Subject 
         Subject  透過 update 連到 Observer
         Main 只需要知道 observer 們 , 跟設定一次 Subject 參數		 


書本第二章(氣象監測系統) : 觀察者模式套用 java.util. Observable(class) / Observer(Interface) 
  優點 : 省去資料結構
  
  說明 : 氣象站 <-(取得資料) Weather 物件 -(顯示)> 顯示裝置 
         氣象站提供 : WeatherData -> getTemperature()          // 取得溫度 
		                           / getHumidity()             // 取得濕度 
								   / getPressure()             // 取得壓力
								   / measurementsChanged()     // 更新資料時呼叫此方法

  								   
  操作 : 主題物件 extends Observable / 訂閱者 implements Observer
     
  實作 : 
    1. WeatherData extends Observable
         屬性 :
           private float temp;
	       private float humidity;
	       private float pressure;

         實踐 :
           1. 無參建構式
           2. get...
           3. measurementsChanged(){ setChanged(); , notifyObservers(); } 
		      // 紀錄並呼叫 , 呼叫 notifyObserves() 前需呼叫 setChanged
              // notifyObserves() 拉取 / notifyObservers(Object args); 推送			  
      
	       4. setMeasurements(float temp , float humidity , float pressure){
				    this.temp = temp;
					this.humidity = humidity;
					this.pressure = pressure;
					measurementsChanged();  
			   }

    2. CurrentConditionDisplay implements Observer , DisplayElement
	     屬性 :
		   private float temp;
		   private float humidity;
		   Observable observable;
		 
         實踐 :
           1. 建構式(Observable observable) -> observable.add(this);
           2. @Override -> display();
           3. @Override -> update(){
		        if (o instanceof WeatherData) {  // 如果 Observable 是 Weather 的訂閱者
				    WeatherData weatherData = (WeatherData)o; // 呼叫主題
				    this.temp = weatherData.getTemp();
				    this.humidity = weatherData.getHumidity();
				    display();
				}
		      }		   
	
         總結 : 
           1. 省略資料結構宣告
           2. setChanged(); 紀錄 -> notifyObservers(); (拉取) / notifyObservers(Object args); (推送)

  
書本第三章(咖啡店) : 裝飾者模式
  
  說明 : 飲料(Beverage) -> 咖啡加上摩卡跟奶泡 
    1. 咖啡物件 extends Beverage 的 cost();
    2. 建立摩卡物件將咖啡物件包(Warp)起 // 裝飾者的型態為被裝飾者 
    3. 建立奶泡物件將摩卡物件包(Warp)起	
	4. 計算 cost 從外往內              			   
    5. 以上知道 -> 
         5-1. 裝飾者與被裝飾者的父類別相同
         5-2. 裝飾者可(1/多)
         5-3. 裝飾者可隨意時機(裝飾前/後)加入新方法

  優點 : 動態的將方法加於物件上 , 比繼承更有彈性		 
  
  設計 :
    class : 
	  1. Beverage -> getDescription(); / abstract cost(); // 被裝飾者
	  2. HouseBlend / DarkRoast // 裝飾者
      3. CondimentDecorator -> 呼叫 getDescription();     // 用於擴充 Beverage 
      4. Milk / Mocha / Whip 	  
  
  實作 :
    
	1. Beverage           -> String description / getDescription() { return description; } / abstract double cost();
	
	2. CondimentDecorator extends Beverage -> public abstract String getDescription(); // 用於改變加料後的描述
  	
    3. DarkRoast extends Beverage (飲料) -> DarkRoast() { description = "DarkRoast"; } // 設定飲料描述用
                                         -> cost() -> return 0.0;                      // 覆寫 cost()
		 									   
    4. Mocha extends CondimentDecorator (料) 
	     -> 紀錄被裝飾者     : Beverage beverage;                                           // 紀錄被裝飾者
		 -> 宣告實放入被裝者 : public Mocha(Beverage beverage){ this.beverage = beverage; } // 配合上方取得被裝飾者
		 -> 覆寫 getDescription(){ return beverage.getDescription()+", Mocha"; }            // 取得先前描述
		 ->                cost(){ return .20+beverage.cost();  }                           // 價格 + 被裝飾者的價格
	
	5. Main 呼叫
         1. 無加料 = 裝飾飲品 -> Beverage beverage = new DarkRoast();
         
         2. 有加料 = 裝飾飲品 + 裝飾料 -> Beverage beverage2 = new DarkRoast(); / beverage2 = new Mocha(beverage);		 
	
  順序 :
    1. Beverage(被裝飾者) -> DarkRoast(裝飾者)    
	                      -> CondimentDecorator(裝飾者(可有可無為了提醒自己要改描述跟分類料與飲)) -> Mocha(裝飾者)
	
	2. 特性 : 裝飾者與被裝飾者的父類別相同

  總結 : 主要靠多型與繼承完成   
						  
-------------------------------------------------------------------		   
	                  	
	 