範例整理 :
 DesignPattern :
   -> session01 :
        DuckDesign -> 工廠練習(FactoryMode) / Book(書本範例) -> new(加入策略模式加簡單工廠模式) / old(未套模式)
        Game       -> 策略模式練習(武器更換)
		StrategyMode -> 策略模式練習(計算機)
   -> session02 : book  -> meteorological (氣象站訂閱者模式練習)		
                           meteorological2(氣象站訂閱者模式練習) // 使用 JavaAPI
			      Drink -> 工廠模式			  
						  
設計概念 :
 1. 把可能需要變動的程式獨立出來
 2. 方法針對介面處理 // "執行時"期動態的"改變"
 3. 多用實作         // 可將細部功能封裝起來
 4. 盡量讓需要互相的物件之間關係鬆綁 // 觀察者模式 

系統是什麼 :
 1. 實現某些功能
 2. 功能複雜時需要由概念整理
 3. 概念轉換為系統架構
 4. 架構進行模組化
 5. 程式碼堆砌而成

設計模式很像模組 , 由物件導向特性組成 

-------------------------------------------------------------------


使用介面的用意 :
 關鍵 "多型" -> 執行時會根據情況到真正的行為不會被綁死到超類別 -(得知)> 變數宣告應該是超類型(抽象 or 介面)
             -> 意味 : 宣告時不用理會執行後的物件型態

-------------------------------------------------------------------


普通工廠模式 : 
  前言 : 你跟工廠說你想要的那種規格的商品      // 商品由工廠產生 
         而工廠負責製造你想要的那種規格的商品  // 工廠提供客製化方法
  
  優點 : 客製化 / 工廠類用於建立物件 / 只需要知道具體產品類名(Duck) / 防止對資料的破壞實現多型((DuckFactoryImpl)duckFactory)
  
  範本 : 
    
	Product : 
	         介面 : Duck -> void NarrativeDuck();
             類別 : DuckImpl implements Duck -> String type / 有無參數建構式 / 覆寫 NarrativeDuck();
    
	Factory :
             介面 : DuckFactory -> Duck getDuck();
             類別 :	DuckFactoryImpl implements DuckFactory -> 覆寫 Duck getDuck() return new Duck; / 
			                                                  超載 Duck getDuck(String type) return new Duck(type); 
    Main :
             1. 呼叫工廠               -> DuckFactory duckFactory = new DuckFactoryImpl(); 	
             2. 由工廠產生商品         -> Duck duck  = duckFactory.getDuck();
			 3. 由工廠產生商品(客製化) -> Duck duck2 = ((DuckFactoryImpl)duckFactory).getDuck("塑膠鴨");
			 4. 實現產品方法           -> duck.NarrativeDuck(); / duck2.NarrativeDuck();
    
	總計 : 由 Main 得知 -> 使用者只需要知道 工廠類方法 / 產品類   

總結: 工廠(類 or 方法) return 類 ? //  

           	
-------------------------------------------------------------------


策略模式 :
  前言 : 定義一系列算法 , 封裝至公共介面
         策略模式用策略的介面來替換在某個實體中的方法 , 可以經由替換不同的策略使得物件擁有不同的行為
		 // 相同型別可以呼叫不同方法

  優點 : 靈活的替換不同的行為 / 策略拓展容易 / 少用 id else  

  範本 : 
    
	Interface : IStrategy -> int caculate(int a , int b); // 公共介面

    策略class : Add / Div / Miuns implements IStrategy
    
    組裝 Calculator : 
	       private IStrategy iStrategy; 
	       public int execute(int a , int b){return iStrategy.caculate(a,b);} // 使用 switch 更換策略
		   public void setStrategy(DoType doType) {}                          // enum DoType{ADD , MINUS , DIVIDE}
		   // this.iStrategy = new Add(); , this.iStrategy = new Miuns(); , this.iStrategy = new Div()
	
    Main : 
	  1. 呼叫 Calculator -> 設定策略.setStrategy(DoType doType)	-> 呼叫方法.execute(1,2)
	    
    總計 : 由 Main 得知 -> 使用者只需要知道組裝後的物件 , 可以隨時更換策略 

總結: 使用公用介面(interface)封裝演算法(class)

-------------------------------------------------------------------


觀察者模式 : 定義了一對多的關係 , 當主題(subject)物件改變 , 訂閱者(observer)改變都會收到通知並自動更新
  
  前言 : 出版者(主題) + 訂閱者(觀察者) = 觀察者模式 
         舉例 : (單)頻道(主題) -(頻道內容改變)-> (多)訂閱觀眾(得到通知)	
         
  
  定義 : 每個物件都可有很多 Observer
    
	interface : Subject  -> registerObserver() / removeObserver() / notifyObserver() // 主題介面 , 利用介面成為觀察者 or 退出
              : Observer -> update() // 所有 Observer 都要實踐 observer 介面 , update() 當主題改變時呼叫	
	
    class     : ConcreteObserver implements Observer -> update() ....
                ConcreteSuject   extends    Subject  -> registerObserver() / removeObserver() / notifyObserver() / getset...	
	            // 
	
  結語 : 
    1. 觀察者模式定義 1 對多
    2. 主題更新 Observer 是透過共同介面
	3. Subject 與 Observer 是鬆綁關系 : Subject 不知道 Observer 的細節
	4. 多 Observer 不可依賴特定順序
	5. 也可透過 java.util. Observable(class) 完成(下方範例)
	
------------------------------------------------------------------- 


單例模式 : 只有一個實例，而且自行實例化並向整個系統提供這個實例

  前言 : 類別只提供創建自己類別的方法
  
  Singleton：很簡單的只有一個類別，其中提供存取自己物件的方法，確保整個系統只有實例化一個物件。





-------------------------------------------------------------------

書本第一章(鴨子模擬器) : 了解設計模式
  零設計模式 :
    一.
      class Duck : quack() / swim() / abstract display()  // 所有鴨都會 quack() / swim() , 每種鴨外觀不同 display()
      class plasticDuck / RedheadDuck extends Duck
     
	二. 加入 fly() 方法
      class Duck : quack() / swim() / fly() / abstract display() // 所有鴨都會 quack() / swim() , 每種鴨外觀不同 display() 	 
      class plasticDuck / RedheadDuck / RubberDuck extends Duck  // RubberDuck 不會飛(問題發生)
	  
    
	導致 : 多次重複 / 不意改變 / 難以得知全部行為 / 改變導致全不受影響 / 每隻鴨子都需要覆寫
	結語 : 由此得知涉及<維護> 為了<再利用> 使用 extends 不會有好結果

  優化 1 -> 把可能需要變動的程式獨立出來 (quack() / fly()) 並提供介面讓細部動作去實做
    
	一. 介面 <--- 細部功能
     interface : Fly -> fly()     <--- FlyYes -> fly(實踐飛行) / FlyNo -> fly(啥都不做) 
	 interface : Quack -> quack() <--- YesQuack -> quack(叫)   / YesQuack -> quack(不叫) / 等等叫聲...
     // 讓 Fly 與 Quack 物件可被再三利用 , 新增細部功能時也不會影響使用其他細部的功能

    二. 設定 Duck
      class Duck : 宣告介面 : Fly fly , Quack quack
	               方法     : swim() / abstract display() / 
				              total(Fly fly , Quack quack){swim() , display() , fly.fly() , quack.quack()}  
	
	三. 設定其他種類 Duck : RubberDuck extends Duck
      class RubberDuck    :覆寫 display();

    四. Main -> Duck RubberDuck = new RubberDuck(); -> RubberDuck.total(new NFly(), new YQuack());

    優點 : 不確定功能獨立出來 , 不用重覆覆寫 , 設定策略即可
	       執行實只需要呼叫主型別並呼叫所有方法設定策略	


書本第二章(氣象監測系統) : 觀察者模式
    
  說明 : 氣象站 <-(取得資料) Weather 物件 -(顯示)> 顯示裝置
         氣象站提供 : WeatherData -> getTemperature()          // 取得溫度 
		                           / getHumidity()             // 取得濕度 
								   / getPressure()             // 取得壓力
								   / measurementsChanged()     // 更新資料時呼叫此方法

  目前知道 : 3 個 get 方法 / 1 個被呼叫方法 / 更需要 3 個顯示(需可擴充)
  
  設計 :
        interface :
		  
		  1. Subject        : void registerObserver(Observer o); / void removeObserver(Observer o); // 主題介面
		                      void notifyObserver();                      
		  
		  2. Observer       : void update(float temp , float humidity , float pressure);  
                              // 當氣象數據改變 , Subject 會把這些參數傳給 Observer		  
		  
		  3. DisplayElement : display()  // 當佈告版需要顯示資料時使用 , 因每個佈告版資料都不同 , 所以獨立出來
        
		Class :
		  1. WeatherData implements Subject :
              屬性 :
			    1. private ArrayList<Observer> observers = new ArrayList<>(); // 多個訂閱者
                2. private float temp;      // 溫度
				3. private float humidity;  // 濕度
				4. private float pressure;	// 氣壓			
		 
		      實踐 :
			    1. registerObserver(Observer o){ observers.add(o); } // 新增 Observer
                2. removeObserver(Observer o)  { int i = observers.indexOf(o); if(i>=0){observers.remove(i)}} // 刪除 Observer
                3. notifyObserver(){ for -> observers.size() -> 得到 Observers.get(i) -> observer.update(....) } 
				   // 更新資料給 observer				
                
			  方法 :	
				1. measurementsChanged() -> 呼叫 notifyObserver();
				2. setMeasurements(float temp , float humidity , float pressure){
				    this.temp = temp;
					this.humidity = humidity;
					this.pressure = pressure;
					measurementsChanged();  
				   }
            
			2. CurrentConditionDisplay implements Observer , DisplayElement
                屬性 :
                  1. private float temp;
	              2. private float humidity;
	            
                建構 :
                  1. public CurrentConditionDisplay(Subject weatherData) { weatherData.registerObserver(this); }
                     // 幫助在 Main 時 , 宣告 CurrentConditionDisplay 時並把自己加入主題
                  
                實踐 : 
                  1. display() -> sout(....)
                  2. update(float temp, float humidity, float pressure){
				        this.temp = temp;
						this.humidity = humidity;
						display();
				     }			  
            
			3. Main : 
                 1. 新建具體的主題物件 WeatherData weatherData = new WeatherData();  
                 2. 新建 Observer = CurrentConditionDisplay conditionDisplay = new CurrentConditionDisplay(weatherData); 
				 3. 更新主題參數

  方法順序 : 
    1. Observer 建構時加入 Subject // 因此 CurrentConditionDisplay 進入 Observers 陣列中
	2. setMeasurements(80, 65, 30) -> measurementsChanged() -> notifyObserver() -> observer.update(temp, humidity, pressure);
	                               -> display()
  
  總結 : Observer 透過建構式加入 Subject 
         Subject  透過 update 連到 Observer
         Main 只需要知道 observer 們 , 跟設定一次 Subject 參數		 


書本第二章(氣象監測系統) : 觀察者模式套用 java.util. Observable(class) / Observer(Interface) 
  優點 : 省去資料結構
  
  說明 : 氣象站 <-(取得資料) Weather 物件 -(顯示)> 顯示裝置 
         氣象站提供 : WeatherData -> getTemperature()          // 取得溫度 
		                           / getHumidity()             // 取得濕度 
								   / getPressure()             // 取得壓力
								   / measurementsChanged()     // 更新資料時呼叫此方法

  								   
  操作 : 主題物件 extends Observable / 訂閱者 implements Observer
     
  實作 : 
    1. WeatherData extends Observable
         屬性 :
           private float temp;
	       private float humidity;
	       private float pressure;

         實踐 :
           1. 無參建構式
           2. get...
           3. measurementsChanged(){ setChanged(); , notifyObservers(); } 
		      // 紀錄並呼叫 , 呼叫 notifyObserves() 前需呼叫 setChanged
              // notifyObserves() 拉取 / notifyObservers(Object args); 推送			  
      
	       4. setMeasurements(float temp , float humidity , float pressure){
				    this.temp = temp;
					this.humidity = humidity;
					this.pressure = pressure;
					measurementsChanged();  
			   }

    2. CurrentConditionDisplay implements Observer , DisplayElement
	     屬性 :
		   private float temp;
		   private float humidity;
		   Observable observable;
		 
         實踐 :
           1. 建構式(Observable observable) -> observable.add(this);
           2. @Override -> display();
           3. @Override -> update(){
		        if (o instanceof WeatherData) {  // 如果 Observable 是 Weather 的訂閱者
				    WeatherData weatherData = (WeatherData)o; // 呼叫主題
				    this.temp = weatherData.getTemp();
				    this.humidity = weatherData.getHumidity();
				    display();
				}
		      }		   
	
         總結 : 
           1. 省略資料結構宣告
           2. setChanged(); 紀錄 -> notifyObservers(); (拉取) / notifyObservers(Object args); (推送)

  
書本第三章(咖啡店) : 裝飾者模式
  說明 :
	  
-------------------------------------------------------------------		   
	                  	
	 
